#### fiber：

- updateQueue：记录更新队列
- alternate：指向当前工作中的 fiber(当前 fiber 的 alternate 就是工作中的 fiber, 工作中的 alternate 就是当前 fiber)
- eventTimes：记录事件次数

- lanes: 标识一种模型

#### 创建流程：

```
1、render ->
2、legacyRenderSubtreeIntoContainer ->
3、legacyCreateRootFromDOMContainer(root 不存在的情况) ->
3.1 createLegacyRoot(创建) ->
ReactDOMBlockingRoot ->
createRootImpl ->
createContainer ->
createFiberRoot(干了三件事儿) ->
3.1.1 createFiber 创建 fiber
3.1.2 createHostRootFiber 创建 fiberRoot
3.1.3 initializeUpdateQueue 初始化 fiber 节点的更新队列
3.2 markContainerAsRoot(将 fiber 节点挂载到 container 对象上)

    3.3、unbatchedUpdates(不开启批量渲染) ->
        3.3.1 updateContainer
            3.3.1.1 requestEventTime(获取程序运行到当前运行的时间) -> now
            3.3.1.2 requestUpdateLane(获取lane模型的值，之前是固定同步SyncLane = 1) ->
                getCurrentPriorityLevel(获取当前任务的优先级) ->
                Scheduler_getCurrentPriorityLevel(返回currentPriorityLevel, 默认是NormalLevel,后续流程会发生优先级变化)

            3.3.1.3 getContextForSubtree(获取当前节点和其父级的上下文) ->
                3.3.1.3.1 getInstance(从组件实例获取reactInternalFiber节点，也就是fiber节点) ->
                3.3.1.3.2 findCurrentUnmaskedContext(获取没有父级的context)

            3.3.1.4 createUpdate(创建update来标记react需要更新的点)
            3.3.1.5 update.payload = { element } (把VDOM挂载给update的payload属性)
            3.3.1.6 enqueueUpdate(将当前update加入到当前fiberRoot的更新队列中，会有很多更新再一个节点上产生)
            3.3.1.7 scheduleUpdateOnFiber(开始进行调度任务) ->
                3.3.1.7.1 checkForNestedUpdates + warnAboutRenderPhaseUpdatesInDEV(检测最大update的数量是否超过了最大值，最大数量是50)
                3.3.1.7.2 markUpdateLaneFromFiberToRoot(跟新当前fiber对象和当前rootRiber根元素，root根元素的到期时间， 也就是跟新当前fiber的lanes)
                3.3.1.7.3 markRootUpdated(标记root有待处理的跟新) ->
                        laneToIndex(计算位运算)
                3.3.1.7.4 getCurrentPriorityLevel(获取当前事件的优先级)
                3.3.1.7.5 lane === SyncLane(同步跟新模式) ->
                    3.3.1.7.5.1 非批量跟新模式和没有正在渲染 ->
                        3.3.1.7.5.1.1 schedulePendingInteractions(在根上注册待处理的交互) ->
                            scheduleInteractions(跟踪这些update,并计数、检测他们是否会报错，调度的交互)
                        3.3.1.7.5.1.2 performSyncWorkOnRoot(同步任务调度)
                3.3.1.7.6 其他更新模式

4、updateContainer(有 root 的情况，直接调用该方法开启更新)
5、getPublicRootInstance(根据 fiberRoot 获取公共 root 实例) -->
getPublicInstance(获取当前的 root 实例)

6、 fiber 更新流程：unstable_scheduleCallback 函数为入口
unstable_scheduleCallback(调度过程的入口)
6.1 getCurrentTime(使用 performance 或 Date 获取当前时间)
6.2 计算过期时间 expirationTime = currentTime + delayTime + 任务优先级时间
6.3 生成新任务 newTask
6.4 如果 startTime > currentTime，说明是延时任务
6.4.1 peek(将 newTask 按照 startTime 的区别推入 timeQueue 延时任务队列)
6.4.2 requestHostTimeout(startTime - current 秒后执行 handleTimeout，将 timeQueue 中的 task 推入 taskQueue)
6.5 反之则是即将要执行的任务
6.5 最后的最后，进入到 requestHostCallback(flushWork) 函数，正式进入更新流程

7、requestHostCallback(flushWork) ->
scheduledHostCallback = callback = flushWork (给全局变量 scheduledHostCallback 赋值 callback) ->
flushWork(主要进行一些变量的状态改变) ->
在 flushWork 内部，正式进入 workLoop 循环任务处理 ->

    flushWork ->
    isHostCallbackScheduled(全局变量，代表调度任务是否执行) ->
    isHostTimeoutScheduled(全局变量，是否有延时任务正在调度;如果有的话，取消这个任务) ->
    正式进入wokLoop函数

hasTimeRemaining 表示当前帧是否还有时间留给 React

8、workLoop, 任务循环调度执行 ->
advanceTimers(检查是否有不过期的任务，并把他们加入到全局变量的新的调度队列中 taskQueue) ->
peek(拿到第一个任务 taskQueue[0]) ->
进入 while 循环，在循环内部，干了这些事儿，主要的功能就是将整个 taskQueue 里面的每个 task 都执行了 ->
8.1、currentTask.expirationTime > currentTime && !hasTimeRemaining && shouldYieldToHost
8.1.1、过期时间大于当前时间，表示任务还没过期
8.1.2、hasTimeRemaining 表示当前帧是否还有时间留给 React
8.1.3、shouldYieldToHost(该函数用来判断当前帧是否还有时间)

    最后通过调用requestHostTimeout(handleTimeout) -> requestHostCallback(flushWork) 进入了loop循环
```
